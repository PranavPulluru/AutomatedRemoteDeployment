# -*- coding: utf-8 -*-
"""ARD

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wPAYbIIFr71Ho2blhpVskF7Tm_vpFdPQ
"""

pip install requests

import math
import requests

class UAVDeployment:
    def __init__(self, drone_max_coverage):
        self.drone_max_coverage = drone_max_coverage
        self.config_mapping_table = {}

    def set_config_mapping(self, terrestrial_config_id, uav_config_ids):
        """
        Set the mapping between a terrestrial config Id and UAV NIB config Ids.
        """
        self.config_mapping_table[terrestrial_config_id] = uav_config_ids

    def calculate_required_uavs(self, cell_radius):
        """
        Calculate the required number of UAVs based on cell radius and UAV max coverage area,
        using the packing formula for optimal circle packing.
        """
        # Area of the cell
        cell_area = math.pi * (cell_radius ** 2)

        # Area of a single UAV coverage circle
        uav_coverage_area = math.pi * (self.drone_max_coverage ** 2)

        # Efficiency factor for circle packing in a circular area
        packing_efficiency = math.sqrt(3) / 2  # Optimal for hexagonal packing

        # Effective coverage area per UAV considering packing efficiency
        effective_uav_coverage = uav_coverage_area * packing_efficiency

        # Calculate the required number of UAVs
        required_uavs = math.ceil(cell_area / effective_uav_coverage)
        return required_uavs

    def calculate_required_uavs_based_on_ues(self, num_ues, supported_ues, cell_radius):
        """
        Calculate the required number of UAVs based on the number of UEs and supported UEs.
        Compare with UAV requirement based on cell radius and return the maximum.
        """
        uavs_based_on_ues = math.ceil(num_ues / supported_ues)
        uavs_based_on_radius = self.calculate_required_uavs(cell_radius)
        return max(uavs_based_on_ues, uavs_based_on_radius)

    def assign_network_configs(self, terrestrial_config_id, num_uavs):
        """
        Assign non-conflicting network configurations to UAVs based on the config mapping table.
        """
        if terrestrial_config_id not in self.config_mapping_table:
            raise ValueError("Terrestrial config Id not found in mapping table.")

        uav_config_ids = self.config_mapping_table[terrestrial_config_id]
        if len(uav_config_ids) < num_uavs:
            print("Too many uavs not enough config ids")
            print(num_uavs)

        return uav_config_ids[:num_uavs]

    def reactive_recovery(self, cell_radius, terrestrial_config_id, num_ues, supported_ues):
        """
        Mandatory reactive recovery: Calculate required UAVs and assign configurations.
        """
        num_uavs = self.calculate_required_uavs_based_on_ues(num_ues, supported_ues, cell_radius)
        uav_configs = self.assign_network_configs(terrestrial_config_id, num_uavs)
        print("Reactive Recovery:")
        print(f"  Required UAVs: {num_uavs}")
        print(f"  Assigned Configurations: {uav_configs}")
        return num_uavs, uav_configs

    def predictive_recovery(self, api_key, location, threshold, cell_radius, terrestrial_config_id, num_ues, supported_ues):
        """
        Optional predictive recovery: Trigger recovery based on weather API data and threshold.
        """
        try:
            weather_data = self.fetch_weather_data(api_key, location)
            weather_condition = weather_data["weather"][0]["main"]
            print(f"Weather Condition: {weather_condition}")

            if weather_condition in ["Storm", "Hurricane", "Extreme"]:
                disaster_probability = 0.9
            elif weather_condition in ["Rain", "Drizzle", "Snow"]:
                disaster_probability = 0.5
            else:
                disaster_probability = 0.2

            print(f"Disaster Probability: {disaster_probability}")

            if disaster_probability > threshold:
                print("Predictive Recovery Triggered!")
                return self.reactive_recovery(cell_radius, terrestrial_config_id, num_ues, supported_ues)
            else:
                print("No action required. Disaster probability is below the threshold.")
                return None
        except Exception as e:
            print(f"Error in predictive recovery: {e}")

    def fetch_weather_data(self, api_key, location):
        """
        Fetch weather data from OpenWeatherMap API for the given location.
        """
        base_url = "https://api.openweathermap.org/data/2.5/weather"
        params = {
            "q": location,
            "appid": api_key,
            "units": "imperial"
        }
        response = requests.get(base_url, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to fetch weather data: {response.status_code}, {response.text}")


if __name__ == "__main__":
    # Initialize the deployment system
    drone_max_coverage = 200  # Maximum coverage radius for each UAV
    deployment = UAVDeployment(drone_max_coverage)
    number_of_UEs = 10000
    supported_UEs = 20

    # Define mapping for terrestrial config Id to UAV NIB config Ids
    deployment.set_config_mapping("terrestrial_001", ["uav_config_01", "uav_config_02", "uav_config_03", "uav_config_04",  "uav_config_04",  "uav_config_04",  "uav_config_04",  "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04", "uav_config_04"])

    # Reactive Recovery
    cell_radius = 1000  # Radius of the cell to be covered
    terrestrial_config_id = "terrestrial_001"
    deployment.reactive_recovery(cell_radius, terrestrial_config_id, number_of_UEs, supported_UEs)

    # Predictive Recovery
    api_key = "209885a003d9240af1fa0f2696efb051"
    location = "Houston"
    threshold = 0.7  # Trigger predictive recovery if disaster probability > 0.7
    deployment.predictive_recovery(api_key, location, threshold, cell_radius, terrestrial_config_id, number_of_UEs, supported_UEs)